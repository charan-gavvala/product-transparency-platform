import express, { Request, Response } from 'express';
import { pool } from '../db';
import PDFDocument from 'pdfkit';
import fs from 'fs';
import path from 'path';

const router = express.Router();

// Generate PDF report for a product
router.post('/:productId/generate', async (req: Request, res: Response) => {
  try {
    const { productId } = req.params;

    // Fetch product data
    const productResult = await pool.query('SELECT * FROM products WHERE id = $1', [productId]);
    
    if (productResult.rows.length === 0) {
      return res.status(404).json({ error: 'Product not found' });
    }

    const product = productResult.rows[0];
    const productData = typeof product.submitted_data === 'string' 
      ? JSON.parse(product.submitted_data) 
      : product.submitted_data;

    // Fetch all questions and answers
    const questionsResult = await pool.query(
      'SELECT * FROM questions WHERE product_id = $1 ORDER BY question_order',
      [productId]
    );

    // Create PDF
    const doc = new PDFDocument({ margin: 50 });
    const reportsDir = path.join(__dirname, '../../reports');
    
    // Create reports directory if it doesn't exist
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }

    const filename = `product-report-${productId}-${Date.now()}.pdf`;
    const filepath = path.join(reportsDir, filename);
    const stream = fs.createWriteStream(filepath);
    doc.pipe(stream);

    // Header
    doc.fontSize(24).text('Product Transparency Report', { align: 'center' });
    doc.moveDown();
    doc.fontSize(12).text(`Generated on: ${new Date().toLocaleDateString()}`, { align: 'center' });
    doc.moveDown(2);

    // Product Information
    doc.fontSize(18).text('Product Information', { underline: true });
    doc.moveDown();
    doc.fontSize(12);
    doc.text(`Product Name: ${product.name}`);
    doc.text(`Category: ${product.category || 'N/A'}`);
    doc.text(`Description: ${product.description || 'N/A'}`);
    doc.text(`Transparency Score: ${product.transparency_score || 'Not calculated'}/100`);
    doc.moveDown(2);

    // Product Details
    doc.fontSize(18).text('Product Details', { underline: true });
    doc.moveDown();
    doc.fontSize(12);

    // Format product data
    const formatValue = (value: any, indent = 0): string => {
      if (typeof value === 'object' && value !== null) {
        return JSON.stringify(value, null, 2);
      }
      return String(value);
    };

    for (const [key, value] of Object.entries(productData)) {
      const formattedKey = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      doc.text(`${formattedKey}: ${formatValue(value)}`);
      doc.moveDown(0.5);
    }

    doc.moveDown();

    // Questions and Answers
    if (questionsResult.rows.length > 0) {
      doc.addPage();
      doc.fontSize(18).text('Question & Answer Summary', { underline: true });
      doc.moveDown();

      questionsResult.rows.forEach((qa, index) => {
        doc.fontSize(12);
        doc.font('Helvetica-Bold').text(`Q${index + 1}: ${qa.question_text}`);
        doc.font('Helvetica').text(`A${index + 1}: ${qa.answer || 'Not answered'}`);
        doc.moveDown();
      });
    }

    // Footer
    doc.fontSize(10).text(
      'This report was generated by the Product Transparency Platform',
      { align: 'center' }
    );

    doc.end();

    stream.on('finish', async () => {
      // Save report record in database
      await pool.query(
        'INSERT INTO reports (product_id, report_pdf_path) VALUES ($1, $2)',
        [productId, filepath]
      );

      // Send PDF as response
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      fs.createReadStream(filepath).pipe(res);
    });

    stream.on('error', (error) => {
      console.error('Error generating PDF:', error);
      res.status(500).json({ error: 'Failed to generate PDF report' });
    });

  } catch (error) {
    console.error('Error generating report:', error);
    res.status(500).json({ error: 'Failed to generate report' });
  }
});

// Get all reports for a product
router.get('/:productId', async (req: Request, res: Response) => {
  try {
    const { productId } = req.params;
    const result = await pool.query(
      'SELECT * FROM reports WHERE product_id = $1 ORDER BY generated_at DESC',
      [productId]
    );
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching reports:', error);
    res.status(500).json({ error: 'Failed to fetch reports' });
  }
});

export default router;

